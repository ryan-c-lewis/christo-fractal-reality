<!doctype html>
<html>
<head>
	<meta charset="utf-8" />
	<link rel="stylesheet" type="text/css" href="reset.css" />
</head>
<body>
<canvas id="julia"></canvas>
<p id="axes" ></p>
<script>
'use strict';

let H = window.innerHeight;
let W = window.innerWidth;

const d = document.getElementById("axes");
d.style.position = "absolute";
d.style.right = "30px";
d.style.top = "30px";
d.style.fontFamily = "Book Antiqua', Palatino, 'Palatino Linotype', 'Palatino LT STD', Georgia, serif";
d.style.fontStyle="italic";
d.style.fontSize="24pt";
d.style.color = "white";
d.style.textShadow = "3px 3px black";

const j = document.getElementById("julia");
const jtx = j.getContext("2d");

let JuliaSeed = { x: 0, y: 0.0 };
const seedChangeSpeed = 0.03;

const originalFocus = { x: 0, y: 0, zoom: 1 };
let currentFocus;

const maxIterations = 100;
const animationSteps = 20;
const zoomFactorPerClick = 5;

function init() {
	document.documentElement.style.overflow = 'hidden'; // remove scrollbars
	jtx.canvas.width = W;
	jtx.canvas.height = H;
	j.style.width = W + "px";
	j.style.height = H + "px";
	j.style.position = "absolute";
	j.style.left = 0 + "px";
	julia(currentFocus);
}

function putPixel(canvasData, x, y, r, g, b, a) {
	var index = (x + y * W) * 4;

    canvasData.data[index + 0] = r;
    canvasData.data[index + 1] = g;
    canvasData.data[index + 2] = b;
    canvasData.data[index + 3] = a; // 0 -- invisible, 255 
}

function updateCanvas(canvas,canvasData) {
    canvas.putImageData(canvasData, 0, 0);
}

function julia(focus) {
	let c_real = JuliaSeed.x;
	let c_imag = JuliaSeed.y;
	var row, col, color = 0;
	var x, y;
	var Z_imag, Z_real, Z2_imag, Z2_real;
    var delta = focus.Delta; 

    var jtxData = jtx.getImageData(0, 0, W, H);
	
	/* Julia set computation */
	y = focus.YMax;
	for(row = 0; row < H; row++){
		x = focus.XMin;
		for(col = 0; col < W; col++){
			color = 0;
			Z_real = x; /* Z := x+yi */
			Z_imag = y;
			
			/* Iteration */
			do {
				/* Z_{n+1} = Z_n^2 + c */
				Z2_real = Z_real * Z_real; 
				Z2_imag = Z_imag * Z_imag;
				Z_imag = 2.0 * Z_imag * Z_real + c_imag;
				Z_real = Z2_real - Z2_imag + c_real;
				color++;
			} while(color < maxIterations && (Z2_real + Z2_imag) < 4.0);

			/* plot pixel */
			if (color < maxIterations)
				putPixel(jtxData, col, row, color, 4*color, 20+color, color * color);
			else
				putPixel(jtxData, col, row, 0, 0, 0, 255);

			x += delta;
		}
		y -= delta;
	}		

	updateCanvas(jtx, jtxData);
}

let pressedKeys = {};
window.onkeyup = function(e) {
	if (pressedKeys["65"])
		alert("Seed: " + JSON.stringify(JuliaSeed) + "\n"
			+ "Zoom: " + JSON.stringify(currentFocus));
	
	pressedKeys[e.keyCode] = false;
}
window.onkeydown = function(e) { pressedKeys[e.keyCode] = true; }

function checkForArrowKeys() {
	if (pressedKeys["37"])
		JuliaSeed.y -= seedChangeSpeed;
	if (pressedKeys["39"])
		JuliaSeed.y += seedChangeSpeed;
	if (pressedKeys["38"])
		JuliaSeed.x -= seedChangeSpeed;
	if (pressedKeys["40"])
		JuliaSeed.x += seedChangeSpeed;
	
	if (!zooming)
		julia(currentFocus);
	
	setTimeout(checkForArrowKeys, 10);
}

window.onmouseup = function() {
	if (zooming)
		return;

	const rect = j.getBoundingClientRect();
	const x = event.clientX - rect.left;
	const y = event.clientY - rect.top;
	const dx = screen_xy_to_real(x, y, currentFocus).x;
	const dy = screen_xy_to_real(x, y, currentFocus).y;
	const dZoom = currentFocus.zoom * zoomFactorPerClick;
	console.log("zooming to: " + dx + ", " + dy);

	let newFocus = getFocus(dx, dy, dZoom);
	zoomTo(currentFocus, newFocus, 1);
}

function screen_xy_to_real(x, y, focus) {
	var dx = focus.XMin + (focus.Delta * x);
	var dy = focus.YMin + (focus.Delta * (H - y));
	// console.log("c = " + dx + " + " + dy + "i");
	return { x: dx, y: dy }
}

function real_xy_to_screen(dx, dy, focus) {
	var x = W - (dx - focus.XMin) / focus.Delta;
	var y = (dy - focus.YMin) / focus.Delta;
	return { x: x, y: y }
}

let zooming = false;
function zoomTo(previousFocus, goalFocus, step) {
	zooming = true;
	if (step < animationSteps) {
		let totalPercent = step / animationSteps;
		let newZoom = currentFocus.zoom + (goalFocus.zoom - currentFocus.zoom) * totalPercent;
		
		let screenPositionAtAnimationStart = real_xy_to_screen(goalFocus.x, goalFocus.y, currentFocus);
		let screenPositionAtAnimationEnd = real_xy_to_screen(goalFocus.x, goalFocus.y, goalFocus);
		let screenXAtAnimationNow = screenPositionAtAnimationStart.x + (screenPositionAtAnimationEnd.x - screenPositionAtAnimationStart.x) * totalPercent;
		let screenYAtAnimationNow = screenPositionAtAnimationStart.y + (screenPositionAtAnimationEnd.y - screenPositionAtAnimationStart.y) * totalPercent;
		let realPositionAtAnimationNow = screen_xy_to_real(screenXAtAnimationNow, screenYAtAnimationNow, getFocus(goalFocus.x, goalFocus.y, newZoom));

		let thisFocus = getFocus(realPositionAtAnimationNow.x, realPositionAtAnimationNow.y, newZoom);
		julia(thisFocus);
		window.setTimeout(function () {
			zoomTo(thisFocus, goalFocus, step + 1)
		}, 20);
	}
	else {
		julia(goalFocus);
		currentFocus = goalFocus;
		zooming = false;
	}
}

function getFocus(x, y, zoom) {
	let focus = {x: x, y: y, zoom: zoom};
	focus.YMin = focus.y - (1 / focus.zoom);
	focus.YMax = focus.y + (1 / focus.zoom);
	focus.Delta = (focus.YMax - focus.YMin) / H;
	focus.XMin = (-1) * (W * focus.Delta) / 2.0 + focus.x;
	return focus;
}

window.onresize = function() {
	W = window.innerWidth;
    H = window.innerHeight;
	init();
} 

window.onload = function() {
	currentFocus = getFocus(originalFocus.x, originalFocus.y, originalFocus.zoom);
	init();
	checkForArrowKeys();
}
</script>
</body>
</html>